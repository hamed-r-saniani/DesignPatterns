زمانی از این الگو استفاده میکنیم که میخواهیم اشیا یک کلاس رو کنترل کنیم و اون ها رو متمرکز کنیم در یک جایی و یک نقطه متمرکز ایجاد کنیم که دسترسی به نمونه های اون شی توسط این کلاس

Proxy

ایجاد بشه

زمانی که این الگو رو میخواهیم پیاده سازی کنیم ما یک کلاس اصلی داریم که هر کلاسی میتونه باشه که یک عملیاتی برای ما انجام میده و ما میخواهیم وقتی کاربر میخواهد از این کلاس اصلی استفاده کنه یکسری شرایط محیا باشه که بخواد از این استفاده کنه و یا قبل و بعد از اجرای این کلاس اصلی در واقع اون عملیاتش بخواییم منطقی رو اجرا کنیم و نخواییم این منطق درون خود کلاس اصلی اجرا بشه در واقع پیاده سازی بشه چون ممکنه کدمون کثیف بشه یا حتی سورس کلاس اصلی رو در دسترس نداشته باشیم

این الگو در واقع یک کلاس هست دقیقا شبیه همون کلاس اصلی رو ایجاد میکنیم و یک نمونه از کلاس اصلی درون کلاس

Proxy

ایجاد میکنیم و کلاینت هامون با این کلاس کار میکنن و اگر بخوان دسترسی به اون کلاس رو داشته باشن منظور همون کلاس اصلی باید یک نمونه از کلاس

Proxy

ایجاد کنن و از این طریق به اون کلاس اصلی دسترسی داشته باشن و اون عملیات مورد نظر رو انجام بدن

مثال در دنیای واقعی:

کارت های اعتباری و پول نقد

پول نقد همون کلاس اصلی ما میشه و بعد از معرفی کارت های اعتباری نیاز به حمل زیاد پول نقد نسیت و در واقع این کارت ها الگوی

Proxy

هست که متصل هست به پول اصلی ما و با اون خرید میکنیم



از

Virtual Proxy

برای کلاس هایی که نمونه سازی اشون هزینه بر هست استفاده میکنیم

--------------------------------------------------------------------------------------------------

البته! الگوی **Proxy** یکی از الگوهای ساختاری است که به شما اجازه می‌دهد تا یک شئ را با یک شئ دیگر که دسترسی به آن را کنترل می‌کند، جایگزین کنید. این الگو معمولاً برای کنترل دسترسی، کاهش هزینه‌های ایجاد شئ‌های سنگین، یا افزودن قابلیت‌های اضافی به شئ اصلی استفاده می‌شود.

### مثال ساده
فرض کنید می‌خواهیم دسترسی به یک سرویس سنگین را کنترل کنیم. برای این کار می‌توانیم از الگوی Proxy استفاده کنیم.

#### پیاده‌سازی
```csharp
using System;

// اینترفیس مشترک
public interface IService
{
    void Execute();
}

// سرویس واقعی (RealSubject)
public class RealService : IService
{
    public void Execute()
    {
        Console.WriteLine("Executing RealService.");
    }
}

// پروکسی (Proxy)
public class ProxyService : IService
{
    private RealService _realService;

    public void Execute()
    {
        if (_realService == null)
        {
            _realService = new RealService();
        }
        Console.WriteLine("ProxyService: Controlling access to RealService.");
        _realService.Execute();
    }
}

// استفاده از الگوی Proxy
public class Program
{
    public static void Main(string[] args)
    {
        IService service = new ProxyService();
        service.Execute();
        // خروجی:
        // ProxyService: Controlling access to RealService.
        // Executing RealService.
    }
}
```

### توضیح مرحله به مرحله
1. **اینترفیس مشترک**: `IService` اینترفیس مشترکی است که هر دو کلاس `RealService` و `ProxyService` آن را پیاده‌سازی می‌کنند.
   
2. **سرویس واقعی (RealSubject)**: کلاس `RealService` پیاده‌سازی واقعی سرویس است که متد `Execute` را اجرا می‌کند.

3. **پروکسی (Proxy)**: کلاس `ProxyService` به عنوان یک واسطه عمل می‌کند. در اینجا، پروکسی دسترسی به `RealService` را کنترل می‌کند و در صورت نیاز آن را ایجاد می‌کند.

4. در بخش `Main`، از `ProxyService` استفاده می‌شود تا دسترسی به `RealService` کنترل شود. پروکسی ابتدا پیغام خود را چاپ می‌کند و سپس متد `Execute` سرویس واقعی را فراخوانی می‌کند.

این مثال نشان می‌دهد که چطور می‌توانیم با استفاده از الگوی Proxy دسترسی به یک شئ را کنترل کنیم و قابلیت‌های اضافی به آن اضافه کنیم بدون اینکه نیاز به تغییر در شئ اصلی باشد.

-----------------------------------------------------------------------------------------------------------

البته، اجازه دهید الگوی **Proxy** را ساده‌تر توضیح دهم با استفاده از یک مثال روزمره.

### مثال روزمره
فرض کنید شما قصد دارید به یک کتابخانه بروید و یک کتاب قرض بگیرید. اما به جای آنکه مستقیماً به کتابدار مراجعه کنید، یک دوستان معتبر دارید که می‌تواند به شما کمک کند. آن دوست شما نقش یک پروکسی را بازی می‌کند. او می‌تواند کنترل کند که آیا شما به کتاب دسترسی دارید یا نه و اگر سوالاتی داشتی، به شما پاسخ دهد.

### ساده‌ترین پیاده‌سازی
بیایید این مفهوم را با یک کد ساده‌تر در C# توضیح دهیم.

#### پیاده‌سازی
```csharp
using System;

// اینترفیس کتابخانه
public interface ILibrary
{
    void BorrowBook();
}

// کتابخانه واقعی
public class RealLibrary : ILibrary
{
    public void BorrowBook()
    {
        Console.WriteLine("Book borrowed from the library.");
    }
}

// پروکسی کتابخانه
public class LibraryProxy : ILibrary
{
    private RealLibrary _realLibrary;

    public void BorrowBook()
    {
        Console.WriteLine("LibraryProxy: Checking access to the real library.");
        
        if (_realLibrary == null)
        {
            _realLibrary = new RealLibrary();
        }

        Console.WriteLine("LibraryProxy: Access granted.");
        _realLibrary.BorrowBook();
    }
}

// استفاده از پروکسی
public class Program
{
    public static void Main(string[] args)
    {
        ILibrary library = new LibraryProxy();
        library.BorrowBook();
        // خروجی:
        // LibraryProxy: Checking access to the real library.
        // LibraryProxy: Access granted.
        // Book borrowed from the library.
    }
}
```

### توضیح به زبان ساده
1. **اینترفیس کتابخانه** (`ILibrary`): این اینترفیس می‌گوید که هر کتابخانه‌ای باید متد `BorrowBook` را داشته باشد.

2. **کتابخانه واقعی** (`RealLibrary`): این کلاس، کتابخانه واقعی است که کتاب را قرض می‌دهد. اجرای متد `BorrowBook` به معنای قرض گرفتن کتاب است.

3. **پروکسی کتابخانه** (`LibraryProxy`): این کلاس نقش دوست شما را بازی می‌کند. پروکسی تصمیم می‌گیرد که آیا دسترسی به کتابخانه واقعی باید داده شود یا نه. هنگامی که دسترسی اعطا شود، پروکسی کتابخانه واقعی را ایجاد می‌کند و سپس متد `BorrowBook` را فراخوانی می‌کند.

4. **استفاده از پروکسی**: در بخش `Main`، به جای استفاده مستقیم از `RealLibrary`، از `LibraryProxy` استفاده می‌کنیم. پروکسی ابتدا چک می‌کند که آیا دسترسی به کتابخانه واقعی باید داده شود یا نه، سپس کتابخانه واقعی را ایجاد می‌کند و متد `BorrowBook` را فراخوانی می‌کند.

این روش به ما اجازه می‌دهد که کنترل بیشتری بر دسترسی به سرویس واقعی (کتابخانه) داشته باشیم و عملیات اضافی مانند چک کردن دسترسی را انجام دهیم.